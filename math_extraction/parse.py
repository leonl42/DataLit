import subprocess 
import argparse
import os
from concurrent.futures import ThreadPoolExecutor
import json
import xml.etree.ElementTree as ET
import resource

def parse_latexml(xml_file):
    """

    PARTLY CHATGPT GENERATED

    Parse the XML file generated by LaTeXML.
    """
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
        return root
    except ET.ParseError as e:
        print(f"Error parsing XML: {e}")
        return None

def get_math_xml_latexml(path):
    """

    PARTLY CHATGPT GENERATED

    Extract math expressions and their associated chapters from the LaTeXML XML structure.
    """

    root = parse_latexml(path)

    math_with_chapters = []
    current_chapter = None

    # Iterate through all elements in the XML tree
    for elem in root.iter():


        # Detect chapters (assuming <chapter> or <section> elements mark chapters)
        if "section" in elem.tag.lower() or "chapter" in elem.tag.lower():
            # Update the current chapter (using title or similar elements)
            attr = elem.attrib
            for key,val in attr.items():
                if "id" in key:
                    current_chapter = val.replace("S","")

        # Detect math elements (inline or display math)
        elif "math" in elem.tag.lower():
            if elem.attrib != {}:
                math_with_chapters.append((current_chapter, elem.attrib["tex"]))

    return math_with_chapters



def get_math_json_pandoc(json_path):
    """
    PARTLY CHATGPT GENERATED 

    Extract math expressions and their associated chapters.
    
    """
    with open(json_path,"r") as f:
        json_data = json.load(f)
        
    chapter = [0]
    math_with_chapters = []

    def extract_from_block(block):
        nonlocal chapter
        # Check block types
        if isinstance(block, dict):
            if block.get("t") == "Header":
                # If it's a chapter header, update the chapter title
                level, _ = block.get("c", [])[0], block.get("c", [])[1]

                if len(chapter) >= level:
                    chapter[level-1] += 1
                    chapter = chapter[:level]
                else:
                    chapter.append(0)

            elif block.get("t") == "Math":
                # Extract math expression and associate it with the current chapter
                math_expr = block.get("c", ["", ""])[1]
                chapter_str = ""
                for c in chapter:
                    chapter_str += str(c) + "."
                chapter_str = chapter_str[:-1]
                math_with_chapters.append((chapter_str, math_expr))
            elif "c" in block and isinstance(block["c"], list):
                # Recursively process nested blocks
                for item in block["c"]:
                    extract_from_block(item)
        elif isinstance(block, list):
            for item in block:
                extract_from_block(item)

    # Traverse through the blocks
    if "blocks" in json_data:
        for block in json_data["blocks"]:
            extract_from_block(block)

    return math_with_chapters


def find_main_tex(path):
    files = os.listdir(path)

    # Try to find the main tex file 
    tex_files = [f for f in files if f.endswith(".tex")]
    tex_files_with_bbl = [f for f in tex_files if f.split(".tex")[0]+".bbl" in files]
    
    # First choice for the main tex file is a .tex file with a matching .bbl file. If there is more than one .tex with matching .bbl we skip that folder
    # Second choice for the main tex file is a .tex from the directory. If there is more than one .tex we skip that folder
    if len(tex_files_with_bbl) == 0:
        if len(tex_files) == 1:
            return tex_files[0]
        else:
            return None
    elif len(tex_files_with_bbl) == 1:
        return tex_files_with_bbl[0]
    else:
        return None
    
def limit_mem(MEM_LIMIT):
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT,MEM_LIMIT))


def parse(tex_path,save_path,main_tex,MEM_LIMIT,TIMEOUT):
    # Takes as input the path to the folder with the .tex and the name of the .tex as a tuple.
    # The .tex file is then parsed using a bash command.
    # Path and file have to be specified separately because the bash command is executed in the directory with the .tex file.
    
    try:
        subprocess.run(["pandoc","{0}".format(main_tex),"-o {0}".format("parsed.json")],timeout=TIMEOUT,check=True,cwd=tex_path, preexec_fn = lambda : limit_mem(MEM_LIMIT),stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        math = get_math_json_pandoc(tex_path+"/"+" parsed.json")

        with open(os.path.join(save_path, "parsed.math")) as f:
            for e in math:
                f.write(str(e) + "\n")

        return "Parsed {0} using pandoc".format(os.path.join(tex_path,main_tex))
    
    except Exception as e1:
        try:

            subprocess.run(["latexml","{0}".format(main_tex),"--output={0}".format("parsed.xml"),"--log={0}".format("parsed.log"),"--quiet"],timeout=TIMEOUT,check=True,cwd=tex_path, preexec_fn = lambda : limit_mem(MEM_LIMIT),stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            math = get_math_xml_latexml(tex_path+"/"+"parsed.xml")
            with open(os.path.join(save_path, "parsed.math"),"w") as f:
                for e in math:
                    f.write(str(e) + "\n")

            return "Parsed {0} using latexml".format(os.path.join(tex_path,main_tex))
        
        except Exception as e2:
            with open(os.path.join(save_path, "failed.error"), "w") as f:
                f.write(str(e1))
                f.write("\n")
                f.write(str(e2))

            return "Failed to parse {0}".format(os.path.join(tex_path,main_tex))


