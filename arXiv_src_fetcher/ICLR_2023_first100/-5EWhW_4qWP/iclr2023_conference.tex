
\documentclass{article} % For LaTeX2e
\usepackage{iclr2023_conference,times}

% Optional math commands from https://github.com/goodfeli/dlbook_notation.
\input{math_commands.tex}

\usepackage{hyperref}
\usepackage{url}

% Our starts here
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage[accsupp]{axessibility} 
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} 
 \usepackage{mathrsfs}
 \usepackage{hhline}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{bbm}
% % \usepackage{subfig}
\usepackage{float}
\usepackage{stfloats}
\usepackage{footmisc}
\usepackage{arydshln}
\usepackage{wrapfig}
% \usepackage{floatrow}
% \usepackage{table}
\usepackage[vlined,linesnumbered,ruled,algo2e]{algorithm2e}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[shortlabels]{enumitem}
\usepackage{custom_commands}
\usepackage{caption}
\usepackage{subcaption}

\title{NTK-SAP: Improving neural network pruning by aligning training dynamics}

% Authors must not appear in the submitted version. They should be hidden
% as long as the \iclrfinalcopy macro remains commented out below.
% Non-anonymous submissions will be rejected without review.

\author{Yite Wang$^1$, Dawei Li$^1$, Ruoyu Sun$^{2,3}$\thanks{Corresponding author.}  \\
$^1$University of Illinois Urbana-Champaign, USA\\ 
$^2$Shenzhen International Center for Industrial and Applied Mathematics,
  \\ $ \;  $ Shenzhen Research Institute of Big Data\\ 
$^3$School of Data Science, The Chinese  University of Hong Kong, Shenzhen, China  \\
\texttt{\{yitew2,dawei2\}@illinois.edu}, \texttt{sunruoyu@cuhk.edu.cn}  \\
}


% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to \LaTeX{} to determine where to break
% the lines. Using \AND forces a linebreak at that point. So, if \LaTeX{}
% puts 3 of 4 authors names on the first line, and the last on the second
% line, try using \AND instead of \And before the third author name.

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy % Uncomment for camera-ready version, but NOT for submission.
\begin{document}


\maketitle

\begin{abstract}
Pruning neural networks before training has received increasing interest due to its potential to reduce training time and memory. One popular method is to prune the connections based on a  certain metric, but it is not entirely clear what metric is the best choice. Recent advances in neural tangent kernel (NTK) theory suggest that the training dynamics of large enough neural networks is closely related to the spectrum of the NTK. Motivated by this finding, we propose to prune the connections that have the least influence on the spectrum of the NTK. This method can help maintain the NTK spectrum, which may help align the training dynamics to that of its dense counterpart. However, one possible issue is that the fixed-weight-NTK corresponding to a given initial point can be very different from the NTK corresponding to later iterates during the training phase. We further propose to sample multiple realizations of random weights to estimate the NTK spectrum. Note that our approach is weight-agnostic, which is different from most existing methods that are weight-dependent. In addition, we use random inputs to compute the fixed-weight-NTK, making our method data-agnostic as well. We name our foresight pruning algorithm Neural Tangent Kernel Spectrum-Aware Pruning (NTK-SAP). Empirically, our method achieves better performance than all baselines on multiple datasets. Our code is available at \url{https://github.com/YiteWang/NTK-SAP}.
\end{abstract}


\section{Introduction}

The past decade has witnessed the success of deep neural networks (DNNs) in various applications. Modern DNNs are usually highly over-parameterized, making training and deployment computationally expensive. Network pruning has emerged as a powerful tool for reducing time and memory costs. There are mainly two  types of  pruning methods: post-hoc pruning \citep{han2015,LTR,molchanov2019importance, OBD, OBS} and foresight pruning \citep{snip, grasp, alizadeh2022prospect, synflow, force, NTT}. The former methods prune the network after training the large network, while the latter methods prune the network before training. In this paper, we focus on foresight pruning. 

SNIP \citep{snip} is probably the first foresight pruning method for modern neural networks. It prunes those initial weights that have the least impact on the initial loss function. SNIP can be viewed as a special case of saliency score based pruning: prune the connections that have the least ``saliency scores'', where the saliency score is a certain metric that measures the importance of the connections. For SNIP, the saliency score of a connection is the difference of loss function before and after pruning this connection. GraSP \citep{grasp} and Synflow \citep{synflow} used two different saliency scores. One possible issue of these saliency scores is that they are related to the initial few steps of training, and thus may not be good choices for later stages of training. Is there a saliency score that is more directly related to the whole training dynamics?

\subsection{Our Methodology}
Recently, there are many works on the global optimization of neural networks; see, e.g.,
\cite{liang2018understanding,liang2018adding,liang2019revisiting,liang2021ReLU,venturi2018spurious, safran2017spurious, li2022benefit, ding2022suboptimal,soltanolkotabi2019theoretical,sun2020GAN, lin2021faster,lin2021landscape, zhang2021expressivity} and the surveys \cite{sun2020global,sun2020optimization}. Among them, one line of research uses neural tangent kernel (NTK) \citep{jacot2018ntk} to describe the gradient descent dynamics of DNNs when the network size is large enough. More specifically, for large enough DNNs, the NTK is asymptotically constant during training, and the convergence behavior can be characterized by the spectrum of the NTK. This theory indicates that the spectrum of the NTK might be a reasonable metric for the whole training dynamics instead of just a few initial iterations. It is then natural to consider the following conceptual pruning method: prune the connections that have the least impact on the NTK spectrum. 
 
There are a few questions on implementing this conceptual pruning method.

First, what metric to compute? Computing the whole eigenspectrum of the NTK is too time-consuming. Following the practice in numerical linear algebra and deep learning \citep{lee2019wide,xiao2020disentangling}, we use the nuclear norm (sum of eigenvalues) as a scalar indicator of the spectrum. 

Second, what ``NTK'' matrix to pick? We call the NTK matrix defined for the given architecture with a random initialization as a ``fixed-weight-NTK'', and use ``analytic NTK'' \citep{jacot2018ntk} to refer to the asymptotic limit of the fixed-weight-NTK as the network width goes to infinity. The analytic NTK is the one studied in NTK theory  \citep{jacot2018ntk}, and we think its spectrum may serve as a performance indicator of a certain architecture throughout the whole training process.\footnote{Please see Appendix \ref{sect:appendix-B2} for more discussions from an empirical perspective.} However, computing its nuclear norm is still too time-consuming (either using the analytic form given in \citet{jacot2018ntk} or handling an ultra-wide network). The nuclear norm of a fixed-weight-NTK is easy to compute,
but the fixed-weight-NTK may be quite different from the analytic NTK. To resolve this issue, we notice a less-mentioned fact: the analytic NTK is also the limit of the expectation (over random weights) of fixed-weight-NTK\footnote{This is a subtle point, and we refer the readers to Appendix \ref{sect:appendix-B1} for more discussions.}, and thus it can be approximated by the expectation of fixed-weight-NTK for a given width. The expectation of fixed-weight-NTK shall be a better approximation of analytic NTK than a single fixed-weight-NTK. Of course, to estimate the expectation, we can use a few ``samples'' of weight configurations and compute the average of a few fixed-weight-NTKs. 

One more possible issue arises: would computing, say, $100$ fixed-weight-NTKs take 100 times more computation cost? We use one more computation trick to keep the computation cost low: for each mini-batch of input, we use a fresh sample of weight configuration to compute one fixed-weight-NTK (or, more precisely, its nuclear norm). This will not increase the computation cost compared to computing the fixed-weight-NTK for one weight configuration with 100 mini-batches. We call this ``\textit{new-input-new-weight}'' (NINW) trick.

We name the proposed foresight pruning algorithm \textbf{N}eural \textbf{T}angent \textbf{K}ernel \textbf{S}pectrum-\textbf{A}ware \textbf{P}runing (\textbf{NTK-SAP}). We show that NTK-SAP is competitive on multiple datasets, including CIFAR-10, CIFAR-100, Tiny-ImageNet, and ImageNet. In summary, our contributions are:
\begin{itemize}
    \item 
    We propose a theory-motivated foresight pruning method named NTK-SAP, which prunes networks based on the spectrum of NTK. 
  \item We introduce a multi-sampling formulation 
 which uses different weight configurations to better capture the expected behavior of pruned neural networks. A ``\textit{new-input-new-weight}'' (NINW) trick is leveraged to reduce the computational cost, and may be of independent interest. 
    \item Empirically, we show that NTK-SAP, as a data-agnostic foresight pruning method, achieves state-of-the-art performance in multiple settings. 
    
\end{itemize}
\section{Related work and background}

\textbf{Pruning after training (Post-hoc pruning).}  Post-hoc pruning can be dated back to the 1980s \citep{janowsky1989pruning, mozer1989using} and they usually require multiple rounds of train-prune-retrain procedure \citep{han2015,OBD}. Most of these pruning methods use magnitude \citep{han2015}, Hessian \citep{OBD, OBS, molchanov2019importance} and other information \citep{dai2018compressing, guo2016dynamic, dong2017learning, yu2018nisp} to define the scoring metrics which determine which weights to prune.  Some other recent works \citep{verma2021sparsifying} identify sparse networks through iterative optimization. Most post-hoc pruning methods intend to reduce the inference time, with the exception of lottery ticket pruning \citep{LTH, LTR} which prunes the networks for the purpose of finding a trainable sub-network. 

\textbf{Pruning during training.} Another class of pruning algorithms gradually sparsifies a dense neural network during training. Some works use explicit $\ell_0$ \citep{louizos2017learning} or $\ell_1$ \citep{wen2016learning} regularization to learn a sparse solution. Other works introduce trainable  masks \citep{liu2020dynamic, savarese2020winning, kang2020operation, kusupati2020soft, srinivas2017training, xiao2019autoprune} or use projected gradient descent \citep{zhou2021effective} to specifically learn the connections to be remained. DST methods \citep{mocanu2018scalable, bellec2017deep, mostafa2019parameter, dettmers2019sparse, liu2021selfish, evci2020rigging, liu2021we, liu2021sparse} train the neural network with a fixed parameter count budget while gradually adjust the parameters throughout training. Moreover, another line of work \citep{you2019drawing} tries to identify the winning ticket at early epochs. These methods can reduce some training time, but often do not reduce the memory cost of training. 

\textbf{Pruning before training (foresight pruning).} SNIP \citep{snip} is arguably the first foresight pruning method. Later, GraSP \citep{grasp} uses Hessian-gradient product to design the pruning metric. To address the layer collapse issue of SNIP and GraSP at high sparsity ratios, Synflow \citep{synflow} prunes the network iteratively in a data-independent manner. FORCE and Iterative SNIP \citep{de2020progressive} also intend to improve the performance of SNIP at high sparsity ratios. \citet{lee2019signal} uses orthogonal constraint to improve signal propagation of networks pruned by SNIP. Neural tangent transfer \citep{NTT} explicitly lets subnetworks learn the full empirical neural tangent kernel of dense networks. PropsPr \citep{alizadeh2022prospect} also mentions the ``shortsightedness'' of existing foresight pruning methods and proposes to use meta-gradients to utilize the information of the first few iterations. 

\section{General pipeline for foresight pruning methods} \label{sect:pruning-pipeline}
In this section, we review the formulation of pruning-at-initialization problem and revisit several existing foresight pruning methods. Here we consider Synflow \citep{synflow}, GraSP \citep{grasp}, SNIP \citep{snip} and Iterative SNIP \citep{force}. When given a dataset $\mathcal{D}={(\mathbf{x}_i,\mathbf{y}_i)}_{i=1}^{n}$ and an untrained neural network $f(\cdot;\boldsymbol{\theta})$ parameterized by $\boldsymbol{\theta}=\{\theta^1, \theta^2, \cdots, \theta^p\} \in \mathbb{R}^{p}$, we are interested in finding a binary mask $\mathbf{m}=\{m^1,m^2,\cdots,m^p\} \in \{0,1\}^{p}$ which minimizes the following equation:
\begin{align}
    \min_{\mathbf{m}}\loss(\mathcal{A}(\boldsymbol{\theta}_0,\mathbf{m}) \odot \mathbf{m}; \mathcal{D}) &= \min_{\mathbf{m}}\frac{1}{n}\sum_{i=1}^{n}\loss(f(\mathbf{x}_i;{\mathcal{A}(\boldsymbol{\theta}_0,\mathbf{m}) \odot \mathbf{m}}),\mathbf{y}_i) \label{eq:formulation}\\ 
    \textrm{s.t.} \quad \mathbf{m} &\in \{0,1\}^{p}, \quad \|\mathbf{m}\|_0 /p \leq d = 1-k\nonumber
\end{align}
where $k$ and $d=1-k$ are the target sparsity and density, $\boldsymbol{\theta}_0 $ is an initialization point which follows a specific weight initialization method $\mathcal{P}$ (e.g. Xavier initialization), $\odot$ denotes the Hadamard product, and $\mathcal{A}$ denotes a training algorithm (e.g. Adam) which takes in mask $\mathbf{m}$ as well as initialization $\boldsymbol{\theta}_0$, and outputs trained weights at convergence $\boldsymbol{\theta}_\text{final} \odot \mathbf{m}$.

Since directly minimizing Equation (\ref{eq:formulation}) is intractable, existing foresight pruning methods assign each mask and corresponding weight at initialization $\theta_0^j$ with a saliency score $S(\theta_0^j)$ in the following generalized form:
\begin{align}
    S(m^j)=S(\theta_0^j)= \frac{\partial \mathcal{I}}{\partial m^j} = \frac{\partial \mathcal{I}}{\partial \theta_0^j} \cdot \theta_0^j \label{eq:saliency}
\end{align}
where $\mathcal{I}$ is a function of parameters $\boldsymbol{\theta}_0$ and corresponding mask $\mathbf{m}$. Intuitively, Equation (\ref{eq:saliency}) measures the influence of removing connection $m^j$ on $\mathcal{I}$. Once the saliency score for each mask is computed, we will only keep the top-$d$ masks. Specifically, the masks with the highest saliency scores will be retained ($m^j=1$), while other masks will be pruned ($m^{j}=0$). 

\textbf{SNIP.} SNIP \citep{snip} defines $S_{\text{SNIP}}(m^j)=\left|\frac{\partial \loss(\boldsymbol{\theta}_0 \odot \boldsymbol{m}; D)}{\partial \theta_0^j} \cdot \theta_0^j\right|$, where $D \subset \mathcal{D}$ is a subset of the whole training set. SNIP prunes the whole network in one round.

\textbf{Iterative SNIP.} The saliency score of Iterative SNIP\footnote{We do not consider FORCE in this work since we find empirically that FORCE is less stable than Iterative SNIP. See Appendix \ref{sect:appendix-snip_variant} for a detailed comparison.} \citep{force} remains the same as the original SNIP. However, multiple rounds of pruning are performed. 

\textbf{GraSP.} GraSP \citep{grasp} defines $S_{\text{GraSP}}(m^j)=-\left[H(\boldsymbol{\theta}_0 \odot \boldsymbol{m}; D)\frac{\partial \loss(\boldsymbol{\theta}_0  \odot \boldsymbol{m}; D)}{\partial \boldsymbol{\theta}_0}\right]^j \cdot \theta_0^j$, where $H$ is the Hessian matrix. Additionally, GraSP is also a single round foresight pruning method.

\textbf{Synflow.} Synflow \citep{synflow} uses $S_{\text{Synflow}}(m^j)=\left|\frac{\partial \sum_k f(\mathbbm{1};{|\boldsymbol{\theta}_0| \odot \boldsymbol{m}})_k}{\partial |\theta_0^j|} \cdot |\theta_0^j|\right|$ as saliency score, where $f_k$ denotes the $k$-th output logit, $\mathbbm{1}$ denotes an input full of $1$s, and $f(\cdot;|\theta_0^j|)$ means replacing all the parameters of the neural network by their absolute values. Similar to Iterative SNIP, Synflow is also an iterative pruning method but in a data-agnostic manner.

\section{Review of neural tangent kernel} \label{sect:relatedwork-NTK}
Recent works \citep{jacot2018ntk, lee2019wide, arora2019exact, xiao2020disentangling} study the training dynamics of large DNNs under gradient descent. 
Formally, let $\mathcal{D} =\{(\mathbf{x}_i,\mathbf{y}_i)\}_{i=1}^{n} \subset \mathbb{R}^{n_0} \times \mathbb{R}^{k}$ denote the training set and let $\mathcal{X} = \{\mathbf{x}:(\mathbf{x},\mathbf{y}) \in \mathcal{D}\}$, $ \mathcal{Y} = \{\mathbf{y}:(\mathbf{x},\mathbf{y}) \in \mathcal{D}\}$ denote inputs and labels, respectively. Consider a neural network $f(\cdot;\boldsymbol{\theta})$ parameterized by weights $\boldsymbol{\theta}$. Let $\loss(\boldsymbol{\theta})=\sum_{(\mathbf{x},\mathbf{y}) \in (\mathcal{X}, \mathcal{Y})} \ell(f(\mathbf{x};\boldsymbol{\theta}),\mathbf{y})$ denote the empirical loss where $\ell$ is the loss function. Thus, $f(\mathcal{X};\boldsymbol{\theta}) \in \mathbb{R}^{kn \times 1}$ is the concatenated vector of predictions for all training inputs. Under continuous time gradient descent with learning rate $\eta$ , the evolution of the parameters $\boldsymbol{\theta}_t$, where we emphasize the dependence of $\boldsymbol{\theta}$ on time $t$, and the training loss of the neural network $\loss$ can be expressed \citep{lee2019wide} as
\begin{align}
    \dot{\boldsymbol{\theta}}_t&=-\eta \nabla_{\boldsymbol{\theta}_t}f(\mathcal{X};\boldsymbol{\theta}_t)^T \nabla_{f(\mathcal{X};\boldsymbol{\theta}_t)}\loss \\
    \dot{\loss} &= \nabla_{f(\mathcal{X};\boldsymbol{\theta}_t)}\loss ^{T}\nabla_{\boldsymbol{\theta}_t}f(\mathcal{X};\boldsymbol{\theta}_t) \dot{\boldsymbol{\theta}}_t = -\eta \nabla_{f(\mathcal{X};\boldsymbol{\theta}_t)}\loss ^{T} \hat{\boldsymbol{\Theta}}_t(\mathcal{X},\mathcal{X}) \nabla_{f(\mathcal{X};\boldsymbol{\theta}_t)}\loss
\end{align}
where we obtain the NTK at time $t$:
\begin{align}
    \hat{\boldsymbol{\Theta}}_t(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_t) \triangleq \nabla_{\boldsymbol{\theta}_t}f(\mathcal{X};\boldsymbol{\theta}_t) \nabla_{\boldsymbol{\theta}_t}f(\mathcal{X};\boldsymbol{\theta}_t)^T
    \in \mathbb{R}^{kn \times kn} .
\end{align}

It is proven that when the width of the neural network becomes sufficiently large \citep{jacot2018ntk, arora2019exact}, the fixed-weight-NTK converges to a deterministic matrix $\boldsymbol{\Theta}(\mathcal{X},\mathcal{X})$, which we term analytic NTK. The analytic NTK remains asymptotically constant throughout training, i.e. $\boldsymbol{\Theta}_t(\mathcal{X},\mathcal{X}) \approx  \boldsymbol{\Theta}_0(\mathcal{X},\mathcal{X}), \; \forall t \ge 0$. 


\textbf{The condition number of the NTK is related to neural network optimization.} The condition number of the NTK is known to be important in neural network optimization. Specifically, let the eigenvalue decomposition of the NTK at initialization be $\boldsymbol{\Theta}_0(\mathcal{X},\mathcal{X})=U^T\Lambda U$ where $\Lambda=\textrm{diag}(\lambda_1, \cdots, \lambda_{kn})$ is the diagonal matrix containing all the eigenvalues of the NTK. 

For large-width networks, the mean prediction of the neural network in the eigenbasis of NTK can be approximately described as $(U\mathbb{E}\left[f(\mathcal{X})\right])_i=(\textbf{I}-e^{-\eta\lambda_i t})(U\mathcal{Y})_i$ \citep{xiao2020disentangling}. Therefore, when using the largest possible learning rate $\eta \sim 2/\lambda_1$ \citep{lee2019wide}, the convergence rate of the smallest eigenvalue is related to $\lambda_1/\lambda_{kn}$, which is the condition number of the NTK. Empirically, the condition number of the NTK has been successfully used to identify promising architectures in the neural architecture search (NAS) field \citep{tenas, MetaNTK-NAS}. 

\textbf{The entire spectrum of the NTK is a better measure.} However, the smallest and the largest eigenvalues only provide very limited information on the optimization property of the DNNs. In the classical optimization theory, the convergence speed depends on all eigenvalues of the Hessians, as different eigenvalues control the convergence of different eigen-modes. Similarly, for neural networks, a few works \citep{kopitkov2020neural,su2019learning} have shown that the convergence speed depends on eigenvalues other than the smallest eigenvalue. In this sense, compared to only considering the condition number of the NTK, controlling the entire eigenspectrum may be a better way to ensure the satisfactory optimization performance of DNNs.

\section{Our method}

\subsection{Account for the effects of the entire eigenspectrum with trace norm}
As discussed in Section \ref{sect:relatedwork-NTK}, the eigenspectrum of the NTK captures the training dynamics of large DNNs, and thus we
intend to use the NTK spectrum to guide foresight pruning. 
More specifically, we would like to keep the spectrum of the pruned network close to that of the large network, so that the pruned network may 
perform similarly to the large network. 

As discussed in Section \ref{sect:pruning-pipeline}, the saliency-score-based method requires using a single metric to capture the optimization performance. This single metric is often a scalar, and thus we want to generate a scalar to capture the information of the whole spectrum. A very natural choice is to use the average value of all eigenvalues. In fact, \citet{pennington2017resurrecting, pennington2018emergence, nasi} indeed analyze the optimization property of DNNs through the average eigenvalues of the NTK (or a related matrix called input-output Jacobian) explicitly or implicitly.
Additionally, using the average eigenvalues have also a few good properties which make it more suitable than other metrics for pruning:

\textbf{Computational efficiency.} To begin with, the computational cost of computing all the eigenvalues would be too expensive. On the contrary, trace norm can be efficiently computed, which we will show in Section \ref{sect:ntk-formulation}.

\textbf{Potentially preserve the entire spectrum.}  As indicated in Section \ref{sect:pruning-pipeline}, the saliency score for each weight measures the change of the metric (here it is the trace norm of the NTK) when removing the weight. More precisely, removing weights with a smaller saliency score is less likely to induce significant change to the eigenvalue distribution. Hence, using the NTK trace norm as the indicator is beneficial in maintaining the entire spectrum.

\subsection{Approximating the trace norm of the NTK} \label{sect:ntk-formulation}

\textbf{Nuclear norm as a proxy of the whole spectrum.} The NTK is a symmetric matrix. Hence, the trace of the NTK is equivalent to the squared Frobenius norm of parameter-output Jacobian, i.e.
\begin{align}
    \|\boldsymbol{\Theta}_0\|_{*}=\|\boldsymbol{\Theta}_0\|_\text{tr}=\|\nabla_{\boldsymbol{\theta}_0}f(\mathcal{X};\boldsymbol{\theta}_0)\|_{F}^2.
\end{align}
\textbf{Finite difference approximation.} Computing the Frobenius norm of the Jacobian matrix $\nabla_{\boldsymbol{\theta}_0}f(\mathcal{X};\boldsymbol{\theta}_0) \in \mathbb{R}^{kn \times p}$ is memory and computation heavy. More specifically, a naive solution that constructs the Jacobian matrix explicitly for a batch of training data may require at least $k$ rounds of backward propagation, where $k$ is as large as 1000 for ImageNet classification task. So approximation is needed. 

One possible way is to lower-bound it using loss gradient with respect to weights $\|\nabla_{\boldsymbol{\theta}_0}\loss\|_{2}^2$. Such a method has been studied in FORCE \citep{force} but found to be inferior to Iterative SNIP.

Alternatively, we use the finite difference expression $\frac{1}{\epsilon}\mathbb{E}_{\Delta \boldsymbol{\theta} \sim \mathcal{N}(\textbf{0},\epsilon\textbf{I})}\left[\|f(\mathcal{X};\boldsymbol{\theta}_0)-f(\mathcal{X};\boldsymbol{\theta}_0+\Delta\boldsymbol{\theta})\|_2^2\right]$ to approximate the Jacobian norm. Please see Appendix \ref{sect:justification} for the justification.

\textbf{Approximating the training set with pruning set.} We use the following finite approximation expression to define a saliency score:
\begin{align}
\label{eq:NTK-SAP}
    S_{\text{NTK-SAP}}(m^j)
= \left|\frac{\partial \mathbb{E}_{\Delta \boldsymbol{\theta} \sim \mathcal{N}(\textbf{0},\epsilon\textbf{I})}\left[\|f(\mathbf{X}_D;\boldsymbol{\theta}_0\odot \textbf{m})-f(\mathbf{X}_D;(\boldsymbol{\theta}_0+\Delta\boldsymbol{\theta})\odot \textbf{m})\|_2^2\right]}{\partial m^j}\right|
\end{align}
where we use the inputs of the pruning dataset $\mathbf{X}_D$ to approximate the whole training inputs $\mathcal{X}$. Our foresight pruning method will use the same framework shown in Section \ref{sect:pruning-pipeline}, which prunes the weights with the least saliency scores defined in Equation (\ref{eq:NTK-SAP}). Nevertheless, a few more tricks are needed to make this method practical, as discussed next.

\subsection{NTK-SAP: multi-sampling formulation} \label{sect:mult-sample-formulation}

The last subsection computes the saliency score using the fixed-weight-NTK.
We think the spectrum of analytic NTK may serve as a performance indicator of a certain architecture.  While a single fixed-weight-NTK can be viewed as an approximation
of the analytic NTK,  the expectation of fixed-weight-NTKs (expecation over random draw of weight configurations) shall be a better approximation. Further, to approximate the expectation, we sample a few independent realization of weight configurations and compute the average of their fixed-weight-NTKs. This helps explore the parameter space and better capture the expected behavior of the pruned neural networks. 

Specifically, with $R$ random weight configurations $\boldsymbol{\theta}_{0,r} \overset{\mathrm{iid}}{\sim} \mathcal{P}$, we use the following stabilized version of the saliency score: 
\begin{align}
    S_{\text{NTK-SAP}}(m^j)
= \left|\frac{\partial \frac{1}{R} \sum_{r=1}^R \mathbb{E}_{\Delta \boldsymbol{\theta} \sim \mathcal{N}(\textbf{0},\epsilon\textbf{I})}\left[\|f(\mathbf{X}_D;\boldsymbol{\theta}_{0,r}\odot \textbf{m})-f(\mathbf{X}_D;(\boldsymbol{\theta}_{0,r}+\Delta\boldsymbol{\theta})\odot \textbf{m})\|_2^2\right]}{\partial m^j}\right|. \label{eq:multi-init}
\end{align} 
There is a major difference between the proposed saliency score and most existing foresight pruning scores: our score is weight-agnostic, i.e., it is not defined by a specific random draw of weight configuration.
In other words, the score is mainly determined by the mask structure 
rather than specific weights.\footnote{Please refer to Appendix \ref{sect:weight-agnostic} for a discussion on whether a good pruning solution should be weight-agnostic.}

\textbf{New-input-new-weight (NINW) trick.} It seems that using multiple weight configurations will cause a large increase in the computational cost.
Nevertheless, by utilizing the fact that the training subset for pruning $D = {(\mathbf{x}_i,\mathbf{y}_i)}_{i=1}^{|D|} \subset \mathcal{D}$ is usually fed into neural networks in multiple batches, we further approximate Equation (\ref{eq:multi-init}) with NINW trick as

\begin{align}
    S_{\text{NTK-SAP}}(m^j)
= \left|\frac{\partial \frac{1}{|D|} \sum_{i=1}^{|D|} \mathbb{E}_{\Delta \boldsymbol{\theta} \sim \mathcal{N}(\textbf{0},\epsilon\textbf{I})}\left[\|f(\mathbf{x}_{i};\boldsymbol{\theta}_{0,i}\odot \textbf{m})-f(\mathbf{x}_{i};(\boldsymbol{\theta}_{0,i}+\Delta\boldsymbol{\theta})\odot \textbf{m})\|_2^2\right]}{\partial m^j}\right|. \label{eq:multi-init-in-data}
\end{align} 
\textbf{Replacing pruning set with random input.} Furthermore, we find that replacing the training subset $D$ with standard Gaussian noise $\mathcal{Z}\sim \mathcal{N}(\textbf{0},\textbf{I})$ can generate comparable performance, which makes NTK-SAP purely data-agnostic. As for Gassuan perturbation, ideally, using multiple draws will indeed give a more accurate approximation. However, we empirically find that a single draw of Gaussian perturbation is good enough to generate satisfactory performance. Hence, by using one random draw of $\Delta \boldsymbol{\theta}$ we have the final data-agnostic NTK-SAP with its saliency score
\begin{align}
    S_{\text{NTK-SAP}}(m^j)
= \left|\frac{\partial \frac{1}{|D|} \sum_{i=1}^{|D|} \left[\|f(\mathbf{z}_{i};\boldsymbol{\theta}_{0,i}\odot \textbf{m})-f(\mathbf{z}_{i};(\boldsymbol{\theta}_{0,i}+\Delta\boldsymbol{\theta}_{i})\odot \textbf{m})\|_2^2\right]}{\partial m^j}\right| \label{eq:multi-init-final}
\end{align} 


where $\boldsymbol{\theta}_{0,i} \overset{\mathrm{iid}}{\sim} \mathcal{P}$, $\Delta \boldsymbol{\theta}_{i} \overset{\mathrm{iid}}{\sim} \mathcal{N}(\textbf{0},\epsilon\textbf{I})$ and $\mathbf{z}_{i} \overset{\mathrm{iid}}{\sim} \mathcal{N}(\textbf{0},\textbf{I})$.
 
In addition, to potentially avoid layer collapse, we also iteratively prune neural networks like Synflow  in $T$ rounds.\footnote{Please refer to Appendix \ref{sect:layer-collapse} for a discussion on why NTK-SAP could potentially avoid layer collapse.}
The major steps of the NTK-SAP algorithm are given in Algorithm \ref{alg:ntksap}.

\textbf{Computational cost.} We compare the computational cost of NTK-SAP with Iterative SNIP as they are both iterative methods and use multi-batch inputs. Since the overhead of the reinitialization process is negligible, NTK-SAP needs roughly double the computational cost of Iterative SNIP due to two forward passes with the computational graph in the formula. However, one should note that NTK-SAP is a data-agnostic method that can be computed beforehand, and the computation time can be reduced with a smaller $T$; thus, the computational overhead is reasonable. Effects of $T$, a detailed comparison of pruning time, and FLOPs comparison can be found in Section \ref{sect:ablation-T}, Appendix \ref{sect:appendix-time}, and Appendix \ref{sect:appendix-flops}, respectively.

\begin{algorithm}[t!]
\caption{Neural Tagent Kernel Spectrum-Aware Pruning (NTK-SAP)}
\label{alg:ntksap}
\begin{algorithmic}[1]
{\small
\REQUIRE Dense network $f(\cdot; \boldsymbol{\theta} \odot \mathbf{m})$, final density $d$, iteration steps $T$, batch size of noise input $B$, perturbation hyperparameter $\epsilon$
\STATE Initialize $\mathbf{m}=\mathbbm{1}$
\FOR{$t$ in $\left[1, \cdots, T\right]$}
  \FOR{$i$ in $\left[1, \cdots, B\right]$} 
    \STATE Reinitialize neural network with $\boldsymbol{\theta}_{0,i} \overset{\mathrm{iid}}{\sim} \mathcal{P}$
    \STATE Sample noise input $\mathbf{z}_{i} \overset{\mathrm{iid}}{\sim} \mathcal{N}(\textbf{0},\textbf{I})$ and parameter perturbation $\Delta \boldsymbol{\theta}_{i} \overset{\mathrm{iid}}{\sim} \mathcal{N}(\textbf{0},\epsilon\textbf{I})$
    \STATE Evaluate saliency scores $\left[\mathcal{S}(\mathbf{m})\right]_i$ based on Equation (\ref{eq:multi-init-final})
 \ENDFOR
 \STATE Calculate $\mathcal{S}(\mathbf{m})=\left|\sum_{i=1}^B\left[\mathcal{S}(\mathbf{m})\right]_i\right|$ 
 \STATE Compute $(1-d^{\frac{t}{T}})$ percentile of $\mathcal{S}(\mathbf{m})$ as threshold $\tau$
 \STATE Update mask $\mathbf{m} \leftarrow \mathbf{m} \odot (\mathcal{S}(\mathbf{m})>\tau) $
\ENDFOR
\RETURN Final mask $\mathbf{m}$
}
\end{algorithmic}
\end{algorithm}

\section{Experiments} \label{sect:main-experiment}

In this section, we empirically evaluate the effectiveness of our proposed method, NTK-SAP (\textcolor{red}{red}). We compare with two baseline methods random pruning (\textcolor{gray}{gray}) and magnitude pruning (\textcolor{magenta}{magenta}), as well as foresight pruning algorithms SNIP (\textcolor{blue}{blue}) \citep{snip}, Iterative SNIP (\textcolor{yellow}{yellow}) \citep{force}, GraSP (\textcolor{green}{green}) \citep{grasp} and Synflow (\textcolor{cyan}{cyan}) \citep{synflow} across multiple architectures and datasets.

\begin{figure}[t]
  \centering
    \includegraphics[width=\textwidth]{plots/test_single_914_main.pdf}
   \caption{Performance of NTK-SAP against other foresight pruning methods. Results are averaged over 3 random seeds, and the shaded areas denote the standard deviation. We highlight SNIP and GraSP as they perform best among baselines on mild and extreme density ratios, respectively.}
   \label{fig:main-comparison}
\end{figure}


\textbf{Target datasets, models, and sparsity ratios.} We develop our code based on the original code of Synflow \citep{synflow}. On smaller datasets, we consider ResNet-20 \citep{resnet} on CIFAR-10, VGG-16 \citep{vgg} on CIFAR-100 \citep{cifar10} and ResNet-18 on Tiny-ImageNet. For ImageNet \citep{deng2009imagenet} experiments, we consider ResNet-18 and ResNet-50. For the training protocols, we roughly follow the settings in \citet{franklemissing}. Details of training hyperparameters can be found in Appendix \ref{sect:experiment-setup}. We divide the sparsity ratios into three ranges: trivial sparsity ratios (36.00\%, 59.04\% and 73.80\%), mild sparsity ratios (83.22\%, 89.30\% and 93.12\%) and extreme sparsity ratios (95.60\%, 97.17\% and 98.20\%). 
 
\textbf{Implementation details.} Following the original implementation, SNIP, GraSP, and Iterative SNIP are run by setting BatchNorm layers as train mode while Synflow metric is evaluated under evaluation mode. The number of training samples for pruning we use is ten times of the number of classes as suggested by the original implementations of SNIP and GraSP. For iterative methods, including Iterative SNIP and Synflow, we prune all the weights in 100 rounds in an exponential schedule following \citet{synflow, franklemissing}. Further, following \citet{franklemissing}, Kaiming normal initialization is used for all models. We prune networks using a batch size of 256 for CIFAR-10/100 and Tiny-ImageNet datasets and a batch size of 128 for ImageNet experiments.

For NTK-SAP, we use the same number of Gaussian noise batches as in Iterative SNIP and prunes neural network progressively in $T=100$ rounds for CIFAR-100 and Tiny-ImageNet. Since the pruning dataset for CIFAR-10 only contains 1 batch of the training sample, we alternatively sample $R=5$ independent initialization points and prune progressively in $T=20$ rounds, keeping the overall computational cost roughly the same. More details can be found in Appendix \ref{sect:experiment-setup}. 

\subsection{Results on CIFAR and Tiny-ImageNet} \label{sect:cifar-tiny}
In Figure \ref{fig:main-comparison} we evaluate NTK-SAP using ResNet-20 on CIFAR-10, VGG-16 on CIFAR-100 and ResNet-18 on Tiny-ImageNet. It can be observed that NTK-SAP is competitive for all sparsity ratios.


\textbf{Trivial and mild sparsity ratios.} For trivial sparsity ratios, all methods show good performance except GraSP, magnitude, and random pruning. On ResNet-20, all methods are similar, while random pruning and GraSP show slightly worse performance. On VGG-16 (ResNet-18), similar trend can be observed while the performance gap is larger. NTK-SAP shows consistent good performance, especially on ResNet-18 (TinyImageNet).

For mild sparsity ratios, NTK-SAP is the only method that performs well across all datasets and models. On ResNet-20, SNIP and Iterative SNIP take the lead with NTK-SAP while suffering from a performance drop starting at 93.12\% sparsity. Magnitude pruning and GraSP have similar performance to NTK-SAP after 89.30\%. On VGG-16 and ResNet-18, NTK-SAP and SNIP remain dominant, while NTK-SAP outperforms SNIP.

\textbf{Extreme sparsity ratios.} NTK-SAP's superior performance can be seen at extreme sparsity ratios, especially 98.20\%. On the CIFAR-10 dataset, GraSP and magnitude pruning are competitive as in matching sparsity ratios. On VGG-16, SNIP first dominates with NTK-SAP and then becomes much inferior. At the sparsest level 98.20\%, magnitude, Iterative SNIP, and GraSP show similar results, about 1 percentage point lower than NTK-SAP. 

\subsection{Results on larger dataset}
We further evaluate the performance of NTK-SAP on more difficult tasks: we run experiments on the ImageNet dataset using ResNet-18 and ResNet-50 with pruning ratios \{89.26\%, 95.60\%\}.\footnote{We choose these sparsity ratios as they include matching and extreme sparsity ratios and close to \{90\%, 95\%\} as used by Iterative SNIP \citep{force} and ProsPr \citep{alizadeh2022prospect}.} We compare NTK-SAP against Synflow, SNIP, Iterative SNIP, GraSP, Magnitude, and Random pruning.

\begin{figure}[!ht]
    \begin{minipage}{\textwidth}
    \begin{minipage}[b]{0.54\textwidth}
    \centering
    \captionof{table}{
    Test performance of foresight pruning methods on the ImageNet dataset. Best results are in \textbf{bold}; second-best results are \underline{underlined}.  }
    \label{tab:benchmark}
    \resizebox{1.0\textwidth}{!}{
    \begin{tabular}[b]{ l cccccc}
    \\
    \hline
    \toprule
    Network & \multicolumn{2}{c}{\textbf{ResNet-18}} &\multicolumn{2}{c}{\textbf{ResNet-50}} \\
    \midrule
    Sparsity percentage & 89.26\% & 95.60\% &  89.26\% & 95.60\% \\ 
    \midrule
    (Dense Baseline) &69.98&&76.20& \\
    \midrule
    Synflow &57.30&45.65& 66.81 & 58.88 \\
    SNIP &57.41 &45.04& 60.98 & 40.69 \\
    Iterative SNIP &52.97 &37.44& 52.53 & 36.82 \\
    GraSP &58.16&\underline{49.17}& \underline{67.74}& \underline{59.73}\\
    Magnitude &\underline{58.75}&48.50&66.80&43.79 \\
    Random &54.48&42.80&65.30&56.53 \\
    \midrule
    \midrule
    \textbf{Our method} &\textbf{58.87}&\textbf{49.43}&\textbf{68.28}&\textbf{60.79} \\
    
    \bottomrule
    \end{tabular}
    }
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.44\textwidth}
    \centering
    \includegraphics[width=1.0\textwidth]{plots/nips_rebuttal/init/comparison6.0_finalfull.pdf}
    \captionof{figure}{Eigenvalue distribution of the fixed-weight-NTK on ResNet-20 (CIFAR-10) at sparsity ratio $73.80\%$. 
    }
    \label{fig:main-eigenspectrum}
    \end{minipage}
    \end{minipage}
\end{figure}


The results are shown in Table \ref{tab:benchmark}. We find that SNIP, which performs reasonably well for smaller datasets, is no longer competitive. For ResNet-50, NTK-SAP beats other pruning methods with margins at least 0.5\% and 1\% for sparsity ratio 89.26\% and 95.60\%, respectively. For ResNet-18, NTK-SAP slightly outperforms magnitude pruning under 89.26\% sparsity, and GraSP follows. For sparsity ratio 95.60 \%, GraSP is better than magnitude pruning while NTK-SAP still takes the lead.


One should note the surprisingly good performance of magnitude pruning. We hypothesize that magnitude pruning chooses an appropriate layer-wise sparsity ratio since Kaiming normal initialization already gives weights different variances depending on the number of parameters of different layers. Thus, layers with more parameters will be more likely pruned. 

\subsection{An overall comparison with SNIP and GraSP}

In this section, we explicitly compare NTK-SAP with two competitive baseline methods in detail, i.e., SNIP and GraSP, since there is no state-of-the-art foresight pruning algorithms \citep{franklemissing}. We highlight both baseline algorithms in Figure \ref{fig:main-comparison}. Specifically, SNIP is considered competitive as it generally performs well, especially for trivial and mild sparsity ratios. However, SNIP shows poor performance for ImageNet. On the contrary, GraSP indeed shows promising performance on the ImageNet dataset and extreme sparsity ratios on smaller datasets, while it suffers from poor performance on trivial and mild sparsity ratios of smaller datasets. In this sense, NTK-SAP is the first foresight pruning algorithm that works consistently well on all datasets.

\subsection{More ablation studies} \label{sect:ablation-T}
We finally evaluate the performance of NTK-SAP when varying the number of iterative steps ($T$), which can give a better understanding of how iterative pruning helps NTK-SAP achieve better performance at higher sparsity ratios. We repeat experiments of Section \ref{sect:cifar-tiny} with varying $T$. Results show that increasing $T$ consistently boosts the performance of NTK-SAP. Moreover, such an increase saturates when $T$ is roughly $1/5$ of the adopted value in Section \ref{sect:cifar-tiny}. Hence, the computational cost of NTK-SAP can be further decreased if we use a smaller value of $T$. Please refer to Appendix \ref{sect:appendix-ablation} for more details. We also conduct an ablation study on the effects of perturbation hyperparameter $\epsilon$. Results show that NTK-SAP is robust to the choices of $\epsilon$. See Appendix \ref{sect:ablation-epsilon} for more details.

\subsection{The eigenspectrum of the fixed-weight-NTK after pruning}
\label{sect:main-eigen}
To visualize the effectiveness of our proposed NTK-SAP method, we show eigenspectrum of pruned subnetwork on CIFAR-10 dataset with ResNet-20 at sparsity ratios $73.80\%$. Figure \ref{fig:main-eigenspectrum} shows that NTK-SAP successfully maintain the eigenspectrum of the fixed-weight-NTK compared to other methods. See Appendix \ref{sect:appendix-eigen-init} for the eigenspectrum of the fixed-weight-NTK for other sparsity ratios.

\section{Conclusion}
Pruning at initialization is appealing compared to pruning-after-training algorithms since it circumvents the need for training to identify the masks. However, most of the existing foresight pruning methods do not capture the training dynamics after pruning. We argue that such an issue can be mitigated by using NTK theory. Hence, we propose NTK-SAP, which iteratively prunes neural networks without any data. Additionally, NTK-SAP pays attention to multiple random draws of initialization points. Empirically, our method is competitive in all datasets and models studied in this work. We consider that our algorithm can encourage more works to apply theoretical findings to empirical applications. Additionally, our novel way of combining multiple initialization configurations may further encourage future work to investigate the similarity of pruning and NAS just like \citet{liu2018rethinking, zeroproxy}. 

The limitations of the work include the relatively heavy computation nature of iterative pruning methods compared to single-shot pruning methods. We also want to emphasize the great significance of pruning methods in reducing the energy cost of training and applying deep learning models.

\newpage
\section{Acknowledgement}
This work utilizes resources supported by the National Science Foundation’s Major Research Instrumentation program, grant No.1725729 \citep{kindratenko2020hal}, as well as the University of Illinois at Urbana-Champaign. This paper is supported in part by Hetao Shenzhen-Hong Kong Science and Technology Innovation Cooperation Zone Project (No.HZQSWS-KCCYB-2022046); University Development Fund UDF01001491 from the Chinese University of Hong Kong, Shenzhen; Guangdong Key Lab on the Mathematical Foundation of Artificial Intelligence, Department of Science and Techonology of Guangdong Province. 

We would like to thank the program chairs and the area chairs for handling our paper. We would also like to thank the reviewers for their time and efforts in providing constructive suggestions on our paper. 


\newpage


\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}



\appendix

\newpage

\section*{Overview of the Appendix}
The Appendix is organized as follows:
\begin{itemize}
    \item \autoref{sect:experiment-setup} introduces the general experimental setup.
    \item \autoref{sect:appendix-intuition} provides intuitions on our multi-sampling formulation.
    \item \autoref{sect:appendix-ablation} shows an ablation study on the number of iterative steps.
    \item \autoref{sect:computational-cost} provides a detailed comparison of computational costs of different foresight pruning methods. 
    \item \autoref{sect:appendix-mag1epoch} provides a further comparison between foresight pruning methods and the early pruning baseline. 
    \item \autoref{sect:appendix-snip_variant} provides a comparison of SNIP variants.
    \item \autoref{sect:all-eigen} shows eigenspectrum of pruned neural networks.
    \item \autoref{sect:full-plots} provides full plots of the main experiments.
    \item \autoref{sect:ablation-epsilon} provides ablation study on the perturbation hyper-parameter $\epsilon$.
    \item \autoref{sect:overview} provides an overview of foresight pruning methods considered in the paper. 
    \item \autoref{sect:compare-NTT} provides a comparison between neural tangent transfer and NTK-SAP.
    \item \autoref{sect:compare-prospr} provides a comparison between ProsPr and NTK-SAP.
    \item \autoref{sect:weight-agnostic} includes a discussion on the weight-agnostic property of NTK-SAP.
    \item \autoref{sect:layer-collapse} includes a discussion on why NTK-SAP can potentially avoid layer collapse.
    \item \autoref{sect:justification} justifies the finite difference formulation used in Section \ref{sect:ntk-formulation}.
    
\end{itemize}

\section{Experimental setup} \label{sect:experiment-setup} 

Our code is based on the original code of Synflow.\footnote{\url{https://github.com/ganguli-lab/Synaptic-Flow}.} The original code does not contain license information. But we obtained approval via email. The authors grant free use for academic purposes.
\subsection{Architecture details} 
The networks architectures are as follows:

\begin{itemize}
    \item For the ResNet-20 model on CIFAR-20 and VGG-16 (with BatchNorm) model on CIFAR-100, we use the default ones used in Synflow \citep{synflow} experiments. Lottery ticket experiments \citep{LTH, LTR, frankle2020linear} use the same architectures.
    \item  For ResNet-18 and ResNet-50, we use the ImageNet version of ResNet models.\footnote{\url{https://github.com/weiaicunzai/pytorch-cifar100}} We use the \texttt{torchvision} implementations.
\end{itemize}

\subsection{Datasets}
We use CIFAR-10, CIFAR-100, Tiny-ImageNet and ImageNet. They do not contain personally identifiable information or offensive content.

\begin{itemize}
    \item CIFAR-10 and CIFAR-100 datasets are augmented by per-channel normalization, applying random cropping (32 $\times$ 32, padding 4), and horizontal flip.
    \item Tiny-ImageNet is augmented by per-channel normalization, choosing a patch with a random aspect ratio between 0.8 and 1.25 and a random scale between 0.1 and 1.0, cropping to 64 $\times$ 64, and random horizontal flip.
    \item  ImageNet dataset is augmented by per-channel normalization, applying random resized cropping to 224 $\times$ 224, and random horizontal flip.
\end{itemize}

\subsection{Training details}
See Table \ref{tab:training-hyperparams} for training hyper-parameters. These hyper-parameters are modified from the ones used in Synflow \citep{synflow} and \citet{franklemissing}. In the following table, we use \texttt{Nesterov} optimizer to denote SGD optimizer with Nesterov momentum.
\input{table/table_hyperparams}

\subsection{Pruning details}
\paragraph{Sparsity ratios} The x-axis for Figure \ref{fig:main-comparison} is in the logarithmic scale of density (1-sparsity). More specifically, we obtain each sparsity ratio by removing 20\% of the remaining parameters twice. For example, the first sparsity ratio is 1-0.8*0.8=0.36. We choose these sparsity ratios to evaluate mainly following the conventional practice used in \citet{franklemissing}. The intuition is that for the first few rounds, the network is over-parameterized and a large portion of the weights can be removed.

\paragraph{Choosing pruning samples.} Different from GraSP implementation, which uses exactly 10 examples of each class, we follow the implementation of SNIP, Iterative SNIP, and Synflow to load multiple batches so that each class roughly has ten samples. 

\paragraph{Pruning batch size.} To compute the saliency scores, we use a pruning batch size of 128 for ImageNet experiments and use 256 otherwise.

\paragraph{BatchNorm layers.} As pointed out by the original Synflow paper, BatchNorm layers are crucial for applying different pruning methods correctly. SNIP, Iterative SNIP, and GraSP prune networks under train mode, while Synflow uses evaluation mode. 
As for NTK-SAP, we compute the saliency score in a modified evaluation mode. More specifically, we first compute batch statistics without constructing a computational graph, and then use the same batch statistics to get an approximation of the NTK nuclear norm under evaluation mode.

\paragraph{Pruning schedule for iterative methods.} Following Synflow, all iterative methods, including Synflow, Iterative SNIP, and NTK-SAP, use an exponential pruning schedule. See Algorithm \ref{alg:ntksap} for how to compute the pruning schedule.

\paragraph{More details about NTK-SAP.} For each round of pruning, we use 40 batches (compared to 79 batches for Iterative SNIP) of noise inputs with a batch size of 128 for ResNet-50 on the ImageNet dataset. For other settings, the number of Gaussian inputs for pruning we use is ten times the number of classes. 

As for the number of pruning rounds $T$, we use 25 for all ImageNet experiments. And we use $T=20$ rounds for ResNet-20 on CIFAR-10 with 5 batches each round (as the batch size is larger than the number of classes 10). For CIFAR-100 and Tiny-ImageNet datasets, we use $T=100$ rounds. 

For $\epsilon$, we use a value of $\epsilon={10}^{-6}$ for ResNet-18 on ImageNet and use a value of $\epsilon={10}^{-4}$ otherwise.

\subsection{Hardware} \label{sect:appendix-hardware} All of our experiments were run on NVIDIA V100s. Experiments on CIFAR-10/100 and Tiny-ImageNet datasets were run on a single GPU at a time. We use 2 and 4 GPUs for ResNet-18 and ResNet-50 in ImageNet experiments, respectively.

\section{Intuition of multi-sampling formulation} \label{sect:appendix-intuition}

\subsection{Understanding multi-sampling formulation through the analytic NTK}
\label{sect:appendix-B1}

In this section, we elaborate on our intuition of performing multi-sampling in NTK-SAP.

We still start our discussion with Equation \ref{eq:NTK-SAP}. We note that Equation \ref{eq:NTK-SAP} alone is not enough to guarantee good performance, as there is actually a gap in applying NTK theory directly to pruning: in a real-world application, the fixed-weight-NTK may differ drastically from the analytic NTK. 

\textbf{Standard expression of the analytic NTK.}
We note that directly using the fixed-weight-NTK to approximate the analytic NTK can be written in the following mathematical formulation:

\begin{equation}
\label{eq:analytic-NTK-limit}
    \boldsymbol{\Theta}(\mathcal{X},\mathcal{X})
   = \underset{ n_l\rightarrow\infty, \forall l}{\lim}
   \hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta})
\end{equation}

where $\boldsymbol{\Theta}$ is the analytic NTK, and $\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\cdot,\cdot;\boldsymbol{\theta})$ is the fixed-weight-NTK for width-$n_l$ neural networks with weight $\boldsymbol{\theta}$. 
A natural way to approximate the analytic NTK is to 
remove the ``lim'' operation and just use  $\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}) $
for  a given set of large enough width $\{ n_l \} $.


\textbf{Two differences of the analytic NTK and the fixed-weight NTK.}
We point out that besides the choice of widths, the choice of weights $\boldsymbol{\theta}$ also affects  $\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}) $. 
In  other words, $\boldsymbol{\Theta}(\mathcal{X},\mathcal{X}) $
 is  both width-agnostic and weight-agnostic,
 while $\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}) $
 is width-dependent and weight-dependent.
 There are two differences between the analytic NTK
 and the fixed-weight-NTK, but the expression \ref{eq:analytic-NTK-limit} only shows
 the difference in width and ignores the difference
 on weights. 
 The underlying reason is that the effects of random weights are offset in an infinite-width network,
 and thus there is no need to eliminate the randomness
 by adding an operator such as expectation. 
 
 \textbf{Another expression of the analytic NTK.}
Although not necessary, it is legitimate to add
an ``expectation'' operator in the expression. 
We rewrite the analytic NTK as the expectation (over random weights) of the limit (over width) of  fixed-weight-NTK, expressed mathematically as follows:
\begin{equation}
\label{eq:analytic-NTK-limit-2}
    \boldsymbol{\Theta}(\mathcal{X},\mathcal{X})
=
\mathbb{E}_{\boldsymbol{\theta}}
\left[ \underset{ n_l\rightarrow\infty, \forall l}{\lim}
\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta})\right].
\end{equation}
This formula is correct
since 
$ \mathbb{E}_{\boldsymbol{\theta}} \left[\underset{ n_l\rightarrow\infty, \forall l}{\lim}\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta})\right]
 = \mathbb{E}_{\boldsymbol{\theta}} \left[\boldsymbol{\Theta}(\mathcal{X},\mathcal{X})\right]
  =\boldsymbol{\Theta}(\mathcal{X},\mathcal{X}) $. 

 
  \textbf{Another approximation of the analytic NTK.}
  Although the expectation operator is redundant in 
  the Equation \ref{eq:analytic-NTK-limit-2},
  it makes a difference when we consider the finite-width approximation. 
  A natural approximation coming out of Equation \ref{eq:analytic-NTK-limit-2} is the following:
  first, remove the ``lim'' operation and  use a fixed set of large enough width $\{ n_l \} $; second, sample multiple independent weight configurations and use the average as an approximation of the ``expectation''  $\mathbb{E}_{\boldsymbol{\theta}}\left[\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta})\right] $
for a given set of large enough width $\{ n_l \} $. Specifically, with $R$ number of independent initialization points, we obtain the stabilized version of the saliency criterion Equation \ref{eq:multi-init}.


\subsection{Understanding multi-sampling formulation through the fixed-weight-NTK evolution}
\label{sect:appendix-B2}
In the previous section, we analyzed why multi-sampling gives a better estimate of the analytic NTK than a single draw of fixed-weight-NTK. 
This analysis leads to the design of multi-sampling method. 
However, it may seem unclear why we want to use the analytic NTK as the performance indicator of a finite-width neural network.
In this section, we provide an explanation of the multi-sampling
method from another perspective. 

When the width goes to infinity, the NTK is almost deterministic and remains asymptotically constant throughout training. 

Under such circumstances, the analytic NTK is a good measure of the optimization of the large enough network since it measures the expected behavior over random weight configurations and training trajectory. Let 
$\boldsymbol{\theta}_t(\boldsymbol{\theta}_0;t)$ denotes the parameter of the network at training step $t$ with initial random weight configuration $\boldsymbol{\theta}_0$, then
\begin{align}
    \boldsymbol{\Theta}(\mathcal{X},\mathcal{X})
=
\mathbb{E}_{\boldsymbol{\theta}_0, t}
\left[ \underset{ n_l\rightarrow\infty, \forall l}{\lim}
\hat{\boldsymbol{\Theta}}^{\{n_l\}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_t(\boldsymbol{\theta}_0;t))\right].
\end{align}

In the finite-width (real-world) setting, the fixed-weight-NTK no longer stays constant and is a function of time. Though we can no longer describe the whole training process with a single deterministic and constant kernel, we can still describe the process with a sequence of NTKs.


For simplicity, we consider a discrete gradient descent update rule. We can characterize the training dynamics of finite-width neural networks with the sequence $\{\hat{\boldsymbol{\Theta}}_0(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_0), \hat{\boldsymbol{\Theta}}_1(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_1), \cdots, \hat{\boldsymbol{\Theta}}_E(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_E)\}$, which contains all the fixed-weight-NTKs at each time step. 


In this case, we hope all the elements in the sequence are well-conditioned so the neural network performs well during the training phase. As a result, we need to quantify the influence of removing a mask on the nuclear norm of these fixed-weight-NTKs. 

One possible metric is  
$ \frac{1}{E+1} \sum_{t=0}^{E} \|\hat{\boldsymbol{\Theta}}_t(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_t)\|_{*}$, which is the average of the nuclear norm of the fixed-weight-NTKs computed on the parameter sequence $\{\boldsymbol{\theta}_0,\boldsymbol{\theta}_1,\cdots,\boldsymbol{\theta}_E \}$. 


We suspect that the parameter space is well explored during the training.The elements in the parameter sequence $\{\boldsymbol{\theta}_0,\boldsymbol{\theta}_1,\cdots,\boldsymbol{\theta}_E\}$ may be well-spread,  %around the 
and thus 
$
\frac{1}{E+1} \sum_{t=0}^{E} \|\hat{\boldsymbol{\Theta}}_t(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_t)\|_{*}
$ can be viewed as an approximation
of
$
\mathbb{E}_{\boldsymbol{\theta}  } \left[\|\hat{\boldsymbol{\Theta}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta})\|_{*}\right]. 
$
As another way to approximate this expectation,
we can  approximate
$
\mathbb{E}_{\boldsymbol{\theta}  } \left[\|\hat{\boldsymbol{\Theta}}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta})\|_{*}\right]
$
by multiple random weight configurations as
$\sum_{r=1}^{R} \|\hat{\boldsymbol{\Theta}}_{0,r}(\mathcal{X},\mathcal{X}; \boldsymbol{\theta}_{0,r})\|_{*}$, which is the saliency criterion Equation \ref{eq:multi-init}.
 
As a comparison, many existing works compute the fixed-weight-NTK with a single random weight configuration at initialization and are hence not a very good measure of the optimization of the network with practical size. In our work, we compute the expected fixed-weight-NTK and we believe such an expected version of the fixed-weight-NTK better captures the expected behavior of the subnetworks over random weight configurations and training trajectory. Hence, we aim to find a subnetwork with a well-conditioned expected fixed-weight-NTK.

To make the expected fixed-weight-NTK well-conditioned, we choose to align it to the fixed-weight-NTK of the dense network at initialization. Such a choice is justified for the following two reasons:
\begin{itemize}
    \item  \textbf{The eigenspectrum of the dense fixed-weight-NTK is a good candidate.} We believe that the good performance of the dense network implies that the eigenspectrum of the dense network at initialization is well-conditioned (See Section \ref{sect:main-eigen} and Appendix \ref{sect:appendix-eigen-init} for the eigenspectrum of the dense network.). 
    \item \textbf{The eigenspectrum of the dense fixed-weight-NTK is a practical choice.} For foresight pruning, we can only access the fixed-weight-NTK at initialization. Also, the foresight pruning framework mentioned in Section \ref{sect:pruning-pipeline} is a general framework that preserves a scalar indicator of the dense network. Hence, due to the intrinsic nature of the framework, we can only try to align the eigenspectrum of the sparse network to the dense counterpart at initialization, rather than some given well-conditioned spectrum.
\end{itemize}

Indeed, for practical networks, the eigenspectrum of the dense network may be changing during the training procedure. Hence, our method can only approximately align the training behavior to the dense network at the early training stage. For the later epochs, the expected well-conditioned property of the subnetwork ensures that the determined subnetworks have a better optimization performance compared to other foresight pruning methods.

\section{Ablation studies on the number of iterative steps} \label{sect:appendix-ablation} 
\begin{figure*}[h]
    \small
        \centering

        \begin{subfigure}[b]{.5\textwidth}  
            \centering
            \includegraphics[width=.95\linewidth]{plots/test_ablation_cifar10.pdf}%[width=.5\linewidth]
            \caption%
            {\small ResNet-20 on CIFAR-10 dataset.} 
            % \label{fig:s1}
        \end{subfigure}
        %\hfill
        \begin{subfigure}[b]{.480\textwidth}  
            \centering 
            \includegraphics[width=.95\linewidth]{plots/test_ablation_cifar100.pdf} %[width=.5\linewidth]
            \caption[]%
            {{\small VGG-16 on CIFAR-100 dataset.}}    
            % \label{}
        \end{subfigure}
        \begin{subfigure}[b]{.5\textwidth}  
            \centering
            \includegraphics[width=.95\linewidth]{plots/test_ablation.pdf}%[width=.5\linewidth]
            \caption%
            {\small ResNet-18 on Tiny-ImageNet dataset.} 
            % \label{fig:s1}
        \end{subfigure}
        
        \caption{Evaluate the effect of number of iterations ($T$) on performance of NTK-SAP on CIFAR-10 (ResNet-20), CIFAR-100 (VGG-16), and Tiny-ImageNet (ResNet-18).} 
        \label{fig:appendix-ablation-T}
        % \vskip -0.2in
\end{figure*}
We show experiment results in Section \ref{sect:ablation-T} here. Figure \ref{fig:appendix-ablation-T} shows that for smaller datasets, we can use a smaller number of iterations $T$ for NTK-SAP without seeing a significant performance drop.

\section{Detailed computational cost} \label{sect:computational-cost}
\subsection{Detailed computational time comparison} \label{sect:appendix-time}
\input{table/table_time}
We include a detailed comparison of the pruning time of considered methods along with the time for 1 epoch of model training in Table \ref{tab:prune-time}. We are interested in comparing the pruning time of NTK-SAP with the training time of 1 epoch since it is empirically shown by \citet{force} that most foresight pruning methods are not worse than magnitude pruning after 1 round of training. We also repeat such experiments in Appendix \ref{sect:appendix-mag1epoch}. 

For ImageNet experiments, the pruning time of NTK-SAP is similar to the time for 1-2 epochs of model training. As for smaller datasets, Appendix \ref{sect:appendix-ablation} shows that we can use a smaller number of pruning rounds $T$. Thus we instead compare the rest of the methods to NTK-SAP with a smaller $T$ for smaller datasets. We name such a modified version \texttt{NTK-SAP-S}. Specifically, we use $T=4$ for CIFAR-10 experiment and use $T=20$ for CIFAR-100 and Tiny-ImageNet. We can see that \texttt{NTK-SAP-S} is able to finish pruning in 1-2 epochs of training time. Thus, we believe that the computational cost of NTK-SAP is reasonable.

\subsection{Detailed FLOPs comparison} \label{sect:appendix-flops}
\input{table/table_flops}
\input{table/table_total_flops}

In this section, we compare different foresight pruning methods in terms of FLOPs. We use the default FLOPs counter in the Synflow codebase. We approximate backward FLOPs twice as the inference/forward FLOPs. Pruning FLOPs are calculated with a simplification that the neural network is dense when computing the gradients.

\paragraph{Pruning cost.} Comparison of pruning cost for different foresight pruning methods are present in Table \ref{tab:appendix-flops-prune}. Synflow has the lowest pruning cost since its saliency score is computed with input containing all 1s. NTK-SAP uses roughly twice the pruning cost compared to Iterative SNIP, making it the method which requires more costs compared to other foresight pruning methods. However, we want to emphasize that the pruning cost of NTK-SAP can be reduced by using smaller $T$ as shown in Section \ref{sect:ablation-T} and Section \ref{sect:appendix-ablation}. 

\paragraph{Inference cost.} We further compare the inference cost of subnetworks found by different foresight pruning methods. Results are present in Table \ref{tab:appendix-flops-inf-cifar10}, \ref{tab:appendix-flops-inf-cifar100} and \ref{tab:appendix-flops-inf-tiny}.

\paragraph{Total pruning and training cost.} Finally, we compare the total pruning and training FLOPs of considered foresight pruning methods in Table \ref{tab:appendix-flops-total-cifar10}, \ref{tab:appendix-flops-total-cifar100} and \ref{tab:appendix-flops-total-tiny}. As discussed in Section \ref{sect:ablation-T}, NTK-SAP generally needs more total computational costs. However, we believe that the additional computational cost is reasonable, especially considering that NTK-SAP is a data-agnostic method and can be easily applied to different datasets once the mask is found. Furthermore, we again want to emphasize the possibility of decreasing the computational cost of NTK-SAP by reducing $T$. 

\section{Early pruning baseline}  \label{sect:appendix-mag1epoch}
\begin{figure}[h]
  \centering
    \includegraphics[width=\textwidth]{plots/test_single_magbase.pdf}
   \caption{Comparison of foresight pruning methods against magnitude pruning after 1 epoch of training. Results are averaged over 3 random seeds and the shaded areas denote the standard deviation of the runs.}
   \label{fig:appendix-mag1epoch}
\end{figure}
We repeat experiments from FORCE \citep{force} where we compare mentioned foresight pruning methods against early pruning. Precisely, we train the dense neural network for 1 epoch and then prune the trained neural network using magnitude pruning. Then the weights are rewound to their initial values as in the LTH work. We term such baseline as \texttt{Mag-1epoch}. Figure \ref{fig:appendix-mag1epoch} illustrates that 1 epoch of training slightly improves the performance of magnitude pruning. However, NTK-SAP still outperforms such an early pruning method.

\section{SNIP variants}
\label{sect:appendix-snip_variant}
\begin{figure}[h]
  \centering
    \includegraphics[width=\textwidth]{plots/SNIP-variants-forcev2.pdf}
   \caption{Comparison of SNIP variants. Results are averaged over 3 random seeds and the shaded areas denote the standard deviation of the runs.}
   \label{fig:appendix-snip-variants}
\end{figure}

\input{table/table_snip_variants}
In this section, we investigate variants of SNIP, including SNIP, Iterative SNIP, and FORCE.

\paragraph{Effects of different sparsity schedules.} We first investigate the effects of the sparsity schedule used in Iterative SNIP. Specifically, we compare Iterative SNIP (Exp), which is used in the main paper, with Iterative SNIP (Linear), where we use a linear sparsity schedule. As is shown in Figure \ref{fig:appendix-snip-variants}, we find that a linear schedule slightly improves the performance of Iterative SNIP on smaller datasets. However, Table \ref{tab:snip-variants-imagenet} shows that the linear schedule does not necessarily improve the performance of Iterative SNIP on larger datasets. 

The performance gap between Iterative SNIP implemented in this work and what is reported in \citep{force} may be due to the different initialization methods and the number of batches used for pruning. Additionally, \citet{force} only considers relatively large neural networks, including VGG-19 and ResNet-50. However, note that it is also empirically shown by \citet{franklemissing} and \citet{synflow}\footnote{See the author feedback file of the Synflow paper.} that Iterative SNIP does not necessarily improve the performance of SNIP.

\paragraph{Unstable performance of FORCE.}In addition, FORCE \citep{force}, which allows pruned masks to resurrect in the process of iterative pruning, is also considered. Results are also presented in Figure \ref{fig:appendix-snip-variants}. We observe a significant performance drop of FORCE on VGG-16 (CIFAR-100). As a result, we do not report FORCE in the main paper.

\section{Eigenspectrum of pruned neural networks} \label{sect:all-eigen}

\subsection{Eigenspectrum at initialization}
\label{sect:appendix-eigen-init}
To visualize the effectiveness of our proposed NTK-SAP method, we conduct experiments on CIFAR-10 dataset with ResNet-20 at sparsity ratios $\{36.00\%, 73.80\%, 89.30\%, 95.60\%, 98.20\%\}$.\footnote{Other datasets have a much larger value of $k$, and thus the fixed-weight-NTK is much more difficult to compute.} We compute the fixed-weight-NTK with a batch size of 100. Thus the fixed-weight-NTK is of size $1000 \times 1000$.



\begin{figure}
  \centering
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/init/comparison2.0_finalfull.pdf}
  \caption{\small sparsity = $36.00\%$}
  \label{fig:appendix-eig-init-2}
  \end{subfigure}
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/init/comparison6.0_finalfull.pdf}
   \caption{\small sparsity = $73.80\%$}
   \label{fig:appendix-eig-init-6}
  \end{subfigure}
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/init/comparison10.0_finalfull.pdf}
   \caption{\small sparsity = $89.30\%$}
   \label{fig:appendix-eig-init-10}
  \end{subfigure}
   \begin{subfigure}[b]{.49\textwidth}
        \includegraphics[width=\textwidth]{plots/nips_rebuttal/init/comparison14.0_finalfull.pdf}
   \caption{\small sparsity = $95.60\%$}
   \label{fig:appendix-eig-init-14}
  \end{subfigure}
    \begin{subfigure}[b]{.49\textwidth}
        \includegraphics[width=\textwidth]{plots/nips_rebuttal/init/comparison18.0_finalfull.pdf}
   \caption{\small sparsity = $98.20\%$}
   \label{fig:appendix-eig-init-18}
    \end{subfigure}
    \caption{Eigenvalue distribution of the fixed-weight-NTK on ResNet-20 (CIFAR-10) at different sparsity ratios. We put the index of each eigenvalue on the x-axis, and the corresponding eigenvalue magnitude is presented on the y-axis.
    }
    \label{fig:appendix-eig-init}
\end{figure}

Figure \ref{fig:appendix-eig-init} shows eigenvalue distributions of neural networks pruned by mentioned foresight pruning methods. It illustrates the effectiveness of NTK-SAP in keeping the spectrum close to the dense network.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/ICLR_rebuttal/compare_w_dense_abs_epoch0.pdf}
  \caption{\small Epoch 0}
  \label{fig:appendix-eig-during-epoch0}
  \end{subfigure}
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/ICLR_rebuttal/compare_w_dense_abs_epoch40.pdf}
   \caption{\small Epoch 40 }
   \label{fig:appendix-eig-during-epoch40}
  \end{subfigure}
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/ICLR_rebuttal/compare_w_dense_abs_epoch80.pdf}
   \caption{\small Epoch 80}
   \label{fig:appendix-eig-during-epoch80}
  \end{subfigure}
   \begin{subfigure}[b]{.49\textwidth}
        \includegraphics[width=\textwidth]{plots/ICLR_rebuttal/compare_w_dense_abs_epoch120.pdf}
   \caption{\small Epoch 120}
   \label{fig:appendix-eig-during-epoch120}
  \end{subfigure}
    \caption{Eigenvalue distribution of the fixed-weight-NTK on ResNet-20 (CIFAR-10) with different training epochs at sparsity ratio 98.20\%. We put the index of each eigenvalue on the x-axis, and the corresponding eigenvalue magnitude is presented on the y-axis.
    }
    \label{fig:appendix-eig-during-epoch}
\end{figure}

As is shown in Figure \ref{fig:appendix-eig-during-epoch}, we see that the spectrum of the dense network is changing throughout the training. On the contrary, the fixed-weight-NTK eigenspectrum of all the pruned networks shows similar behavior and deviates from the dense one. However, we show that, compared to other foresight pruning methods, the eigenspectrum of  NTK-SAP aligned with the dense counterpart for the first few epochs (As it is shown that the majority of the eigenvalues of NTK-SAP are the closest to the dense network for most of the time.). Secondly, the fixed-weight-NTK of NTK-SAP is well-conditioned throughout the entire training process, which aligns with our motivation.

\subsection{Eigenspectrum during training}

\begin{figure}
  \centering
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/during/itersnip.pdf}
  \caption{\small Iterative SNIP}

  \end{subfigure}
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/during/grasp.pdf}
   \caption{\small GraSP}

  \end{subfigure}
  \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/during/mag.pdf}
   \caption{\small Magnitude}

  \end{subfigure}
   \begin{subfigure}[b]{.49\textwidth}
        \includegraphics[width=\textwidth]{plots/nips_rebuttal/during/snip.pdf}
   \caption{\small SNIP}

  \end{subfigure}
    \begin{subfigure}[b]{.49\textwidth}
        \includegraphics[width=\textwidth]{plots/nips_rebuttal/during/synflow.pdf}
   \caption{\small Synflow}

    \end{subfigure}
    \begin{subfigure}[b]{.49\textwidth}
    \includegraphics[width=\textwidth]{plots/nips_rebuttal/during/NTKSAP.pdf}
   \caption{\small NTK-SAP (Ours)}

    \end{subfigure}
    \caption{Relative eigenvalue distribution of the fixed-weight-NTK during training on ResNet-20 (CIFAR-10) at sparsity 98.20\%. We put the index of each eigenvalue on the x-axis, and the corresponding relative eigenvalue magnitude is presented on the y-axis.
    }
    \label{fig:appendix-eig-during}
\end{figure}

We also plot eigenvalue distributions of neural networks pruned by these foresight pruning methods during training. Since the test performance of different methods does not vary too much on the CIFAR-10 dataset for a wide range of sparsity ratios, we only focus on the most extreme sparsity, i.e, 98.20\%. We report relative eigenvalues by dividing each eigenvalue by the average of 10\% smallest eigenvalues. Results are presented in Figure \ref{fig:appendix-eig-during}.

We observe that the best three methods on the CIFAR-10 dataset, i.e, NTK-SAP, GraSP, and Magnitude, have relatively low condition numbers. Furthermore, the best two methods, i.e., GraSP and NTK-SAP, have almost stable/unchanging relative eigenvalue distribution during training. That could possibly explain why GraSP and NTK-SAP perform well at this sparsity ratio.
\section{Full plots of the main experiments} \label{sect:full-plots}

\begin{figure}
  \centering
%   \includegraphics[width=\textwidth]{plots/main-comparison.pdf}
    \includegraphics[width=0.8\textwidth]{plots/appendix-train-full.pdf}
   \caption{Train accuracy of NTK-SAP against other foresight pruning methods. Results are averaged over 3 random seeds and the shaded areas denote the standard deviation of the runs.}
   \label{fig:appendix-train-full}
%   \vspace{-1em}
\end{figure}

\begin{figure}
  \centering
%   \includegraphics[width=\textwidth]{plots/main-comparison.pdf}
    \includegraphics[width=0.8\textwidth]{plots/appendix-test-full.pdf}
   \caption{Test accuracy of NTK-SAP against other foresight pruning methods. Results are averaged over 3 random seeds and the shaded areas denote the standard deviation of the runs.}
   \label{fig:appendix-test-full}
%   \vspace{-1em}
\end{figure}
We further include the complete plots of train/test accuracy of the main experiments reported in Section \ref{sect:cifar-tiny}. Results are shown in Figure \ref{fig:appendix-train-full} and Figure \ref{fig:appendix-test-full}. NTK-SAP provides higher training accuracy than other foresight pruning methods, showing its capability to identify  subnetworks that are easier to train. 

Generally, the test performance of all foresight pruning methods degrades with more sparsity induced. And the speed of performance degradation accelerates as the sparsity ratio increases. Additionally, for VGG-16 (CIFAR-100) and ResNet-18 (Tiny-ImageNet), it can be clearly seen that the test performance of NTK-SAP first increases and then decreases, which shows the generalization improvements brought by pruning. However, it is not observed in ResNet-20 (CIFAR-10).

\section{Ablation study on perturbation hyper-parameter} \label{sect:ablation-epsilon}
In this section, we conduct an ablation study on the effects of choosing different values of perturbation hyper-parameter $\epsilon$. We choose $\epsilon$ from $\{1.0 \times 10^{-4}, 2.5 \times 10^{-5}, 1.0 \times 10^{-5}, 1.0 \times 10^{-6}\}$, where $1.0 \times 10^{-4}$ is the value we used in the main body. Results on CIFAR-10, CIFAR-100, and Tiny-ImageNet are shown in Table \ref{tab:appendix-ablation-perturb-cifar10}, \ref{tab:appendix-ablation-perturb-cifar100}, and \ref{tab:appendix-ablation-perturb-tiny}, respectively. 

The tables show that NTK-SAP is robust to the choices of perturbation hyper-parameter $\epsilon$.
\input{table/table_perturb_param}

\section{Overview of the considered foresight pruning methods} \label{sect:overview}

\input{table/table_overview}
\paragraph{Synflow and NTK-SAP are the only two data-free foresight pruning methods.} In this section, we summarize all the mentioned foresight pruning methods in Table \ref{tab:appendix-overview}. Synflow and NTK-SAP are the only foresight pruning methods that do not need any data. It indicates that once pruning is done, subnetworks found can be easily applied to different datasets. Moreover, to our best knowledge, NTK-SAP is the first foresight pruning method that is weight agnostic.

\section{Difference between NTK-SAP and Neural Tangent Transfer} \label{sect:compare-NTT}

In this section, we briefly discuss the difference between NTK-SAP and Neural Tangent Transfer (NTT) \citep{NTT}. NTT also uses the theory of NTK to guide foresight pruning. Its goal is to jointly optimize $\mathbf{m}$ and $\boldsymbol{\theta}$ so that the output and the fixed-weight-NTK of the pruned model are as close as to the dense counterpart. 

However, the computational cost of explicitly constructing the fixed-weight-NTK is much larger than that of estimating the spectrum
used in NTK-SAP. 
As a result, NNT may be too expensive to use for large models
 including ResNet-18, ResNet-34, and ResNet-50.\footnote{See related discussions in issue $\#$2 of NTT GitHub page.}
% may greatly limit the practical use of NTT compared to NTK-SAP. 
Indeed, the original NTT paper only considers small networks, including multi-layer perceptrons, LeNet, and Conv-4. 

% We suspect that it is not easy to scale-up NTT to larger models


Another question is: can we apply the approximation used in NTK-SAP to NTT? We believe it is not trivial. The idea of NTK-SAP is to remove those masks that have the least influence on the fixed-weight-NTK spectrum. Hence, the spectrum is likely to stay roughly the same after pruning. On the contrary, NTT, as an optimization-based method, may need extra efforts to modify the loss to penalize the change of the fixed-weight-NTK spectrum since two spectrums can have the exact summation but with totally different cumulative distribution functions (CDF).



\section{Comparison with ProsPr} \label{sect:compare-prospr}
Before submission, it has come to our attention that ProsPr \citep{alizadeh2022prospect} has been published recently as a new competitive foresight pruning method. We tried to reproduce the results of ProsPr  so that we can conduct a fair comparison between ProPr and NTK-SAP.\footnote{Note that there are some differences between architectures used in ProsPr and the benchmark they used \citep{franklemissing}.} Nevertheless, we are unable to reproduce the reported results in the original ProsPr paper.
We suspect that this is because we did not use the same hyperparameters
as the authors, and then asked the authors for their hyperparameters.
The authors told us that the hyper-parameters information is not yet released and will be released later some time. 
We will conduct such a comparison once this information is available. 


However, we want to emphasize that, ProsPr, as a data-dependent method (See Table \ref{tab:appendix-overview}), requires data to perform the pruning procedure. On the contrary, NTK-SAP does not require any data. Once the model is pruned, it can be applied to any datasets without additional computation.

\section{Discussion on the weight-agnostic property of NTK-SAP} \label{sect:weight-agnostic}

In Section \ref{sect:mult-sample-formulation} we have discussed the weight-agnostic property of NTK-SAP. Here we include a discussion on if a good pruning solution should also be weight-agnostic, at least in the sense of expectation.

We think it depends on the type of pruning methods. For post-hoc pruning, a good pruning solution may be weight-dependent. For example, when using one good post-hoc pruning method "lottery ticket algorithm" \citep{LTH}, mask-dependent weight configuration performs better than random weight configurations. 

However, as pointed out by \citep{franklemissing}, most existing foresight pruning methods are not very sensitive to newly sampled initialization. One reason could be that foresight pruning methods do not have access to enough information to learn the local features/patterns of the images \citep{pellegrini2022neural} or the basin of the pruning solution \citep{evci2022gradient}. So in this sense, a good solution for foresight pruning may be weight-agnostic. Anyhow, this argument is not decisive evidence that the best foresight pruning method shall be weight-agnostic. 

Another question may be since NTK-SAP intends to find subnetworks that perform well in expectation, what happens if a really bad initialization that has zero overlaps with the binary mask? Will this network be trained well? We believe that such a network indeed should not be trained well. However, the probability of such a situation is 0 since known initialization methods, e.g., Xavier or Kaiming normalization, draw initial weights from continuous random distributions. Furthermore, if a worst-case initialization is allowed, a dense network can also encounter an all-zero initialization which leads to poor results.

\section{Why NTK-SAP can potentially avoid layer collapse} \label{sect:layer-collapse}
In Section \ref{sect:mult-sample-formulation} we mention that NTK-SAP uses iterative pruning to potentially avoid layer collapse. We would like to give a possible explanation of why NTK-SAP implicitly avoids layer collapse for the following reasons:

Firstly, Synflow \citep{synflow} proves that synaptic saliency-based foresight pruning methods broadly follow conservation law and iterative pruning can help them avoid layer collapse. As a result, NTK-SAP, as an iterative synaptic saliency-based pruning method, could also theoretically avoid layer collapse.

Secondly, \citet{lee2019signal} is a re-initialization method based on SNIP aiming at improving signal propagation when layer collapse is about to happen. This work reveals that when layer collapse is about to occur, the spectrum of the layer-wise input-output Jacobian is extremely poor so it breaks layer-wise dynamical isometry. Similarly, the spectrum of the NTK can also serve as such an indicator. Specifically, it can be proved that when layer collapse is about to happen, the spectrum of the NTK deteriorates as well. Here, we would like to give a simple example for a better understanding. For example, when layer collapse happens, the weight gradients of DNNs will be zeros and the fix-weight-NTK will be a zero matrix with all zero eigenvalues. In this sense, NTK-SAP works in a way very similar to Iterative SNIP \citep{force} to avoid layer collapse.

\section{Justification of finite difference formulation} \label{sect:justification}

In this section we justify the finite difference formulation we used in Section \ref{sect:ntk-formulation}. To justify this approximation, we have 
\begin{align*}
& \mathbb{E}_{\Delta \boldsymbol{\theta} \sim \mathcal{N}(\textbf{0},\epsilon\textbf{I})}\left[\|f(\mathcal{X};\boldsymbol{\theta}_0)-f(\mathcal{X};\boldsymbol{\theta}_0+\Delta\boldsymbol{\theta})\|_2^2\right] \\
\approx & \mathbb{E}_{\Delta\boldsymbol{\theta}}\left[\|\nabla_{\boldsymbol{\theta}_0}f(\mathcal{X};\boldsymbol{\theta}_0)\Delta\boldsymbol{\theta}\|_2^2\right]\\
% = \mathbb{E}_{\Delta\boldsymbol{\theta}}\left[\sum_i{\big( \sum_j{\left[\nabla_{\boldsymbol{\theta}_0}f(\mathcal{X};\boldsymbol{\theta}_0)\right]_{i,j}\Delta\theta_j}}\big)^2\right]
=&\sum_{i,j}\left[\nabla_{\boldsymbol{\theta}_0}f(\mathcal{X};\boldsymbol{\theta}_0)\right]_{i,j}^2\mathbb{E}\left[\Delta\theta_j\Delta\theta_j\right] \\
=& \epsilon\|\nabla_{\boldsymbol{\theta}_0}f(\mathcal{X};\boldsymbol{\theta}_0)\|_F^2 .
\end{align*}
\end{document}
